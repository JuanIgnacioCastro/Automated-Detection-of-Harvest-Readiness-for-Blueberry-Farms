# -*- coding: utf-8 -*-
"""finalpresentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LfNG0H56n5KiC5cIz5yA6dIGwgtVqzWg
"""

# ======================================================================
# BLUEBERRY FARM HARVEST SIMULATION (ONE-CELL VERSION)
# Ripening model + farm scaling + prices + unified manual vs machine logic
# ======================================================================

import numpy as np
import pandas as pd
from scipy.stats import lognorm
import matplotlib.pyplot as plt

# Make DataFrame print nicely (optional)
pd.set_option('display.float_format', lambda x: f'{x:,.2f}')

# ======================================================================
# 1) RIPENING MODEL (SINGLE PLANT, 90 DAYS, LEFT-SKEWED LOGNORMAL)
# ======================================================================

TOTAL_KG = 4.0               # total kg per plant in the season
BERRY_WEIGHT_G = 1.5         # grams per berry
TABLE_END_DAY = 90           # simulate days 0..90
HARVEST_LIFE_DAYS = 7        # a ripe berry is marketable for 7 days
GREEN_WINDOW_DAYS = 10       # "visible green" window before ripening

days = np.arange(TABLE_END_DAY + 1)

# --- left-skewed log-normal daily production fraction ---
shape = 0.3947
scale = 40.5263

right_skew = lognorm.pdf(days + 1, shape, scale=scale)
right_skew /= right_skew.sum()

left_skew = right_skew[::-1]
left_skew /= left_skew.sum()

daily_frac = left_skew  # fraction of the season’s production that appears each day

# --- convert fraction → kg and berries per day ---
kg_per_day = TOTAL_KG * daily_frac
total_berries = TOTAL_KG * 1000.0 / BERRY_WEIGHT_G
berries_per_day = total_berries * daily_frac

cum_kg = kg_per_day.cumsum()
remaining_kg = TOTAL_KG - cum_kg

cum_ripened = berries_per_day.cumsum()
remaining_berries = total_berries - cum_ripened

# --- harvestable (ripe) berries = last HARVEST_LIFE_DAYS ---
harvestable = []
for T in days:
    start = max(0, T - HARVEST_LIFE_DAYS + 1)
    end = T
    harvestable.append(berries_per_day[start:end+1].sum())
harvestable = np.array(harvestable)
lost_berries = cum_ripened - harvestable

# --- green berries that will ripen within GREEN_WINDOW_DAYS ---
green_on_bush = []
for T in days:
    start = T + 1
    end = min(T + GREEN_WINDOW_DAYS, TABLE_END_DAY)
    if start > end:
        green_on_bush.append(0.0)
    else:
        green_on_bush.append(berries_per_day[start:end+1].sum())
green_on_bush = np.array(green_on_bush)

visible_for_ratio = green_on_bush + harvestable

blue_ratio = []
for h, vis in zip(harvestable, visible_for_ratio):
    if vis == 0:
        blue_ratio.append(np.nan)
    else:
        blue_ratio.append(h / vis)

# --- base plant DataFrame ---
df = pd.DataFrame({
    "day": days,
    "daily_frac": daily_frac,
    "kg": kg_per_day,
    "cum_kg": cum_kg,
    "remaining_kg": remaining_kg,
    "berries_per_day": berries_per_day.astype(int),
    "harvestable_berries": harvestable.astype(int),
    "lost_berries": lost_berries.astype(int),
    "remaining_berries": remaining_berries.astype(int),
    "green_on_bush": green_on_bush.astype(int),
    "visible_for_ratio": visible_for_ratio.astype(int),
    "blue_ratio": np.round(blue_ratio, 3)
})

df["daily_frac"] = df["daily_frac"].round(6)
df["kg"] = df["kg"].round(4)
df["cum_kg"] = df["cum_kg"].round(4)
df["remaining_kg"] = df["remaining_kg"].round(4)

# ======================================================================
# 2) HOW MUCH OF THE CROP FALLS IN EACH 30-DAY BLOCK? (OPTIONAL)
# ======================================================================

total_berries_season = df["berries_per_day"].sum()
first_30 = df.loc[df["day"].between(0, 29), "berries_per_day"].sum()
second_30 = df.loc[df["day"].between(30, 59), "berries_per_day"].sum()
third_30 = df.loc[df["day"].between(60, 89), "berries_per_day"].sum()

pct_first = first_30 / total_berries_season * 100
pct_second = second_30 / total_berries_season * 100
pct_third = third_30 / total_berries_season * 100

print("Distribution of berries in thirds of the season:")
print(f"  First 30 days : {pct_first:5.1f}%")
print(f"  Second 30 days: {pct_second:5.1f}%")
print(f"  Third 30 days : {pct_third:5.1f}%")

# ======================================================================
# 3) SCALE TO FARM LEVEL
# ======================================================================

plant_count = 12000

# columns that are counts or kg
cols_to_scale = [
    "kg",
    "cum_kg",
    "remaining_kg",
    "berries_per_day",
    "harvestable_berries",
    "lost_berries",
    "remaining_berries",
    "green_on_bush",
]

DataFrameFarm = df.copy()

for col in cols_to_scale:
    DataFrameFarm[col] = DataFrameFarm[col] * plant_count

# rename scaled columns with 'farm_' prefix
rename_map = {col: f"farm_{col}" for col in cols_to_scale}
DataFrameFarm = DataFrameFarm.rename(columns=rename_map)

# DataFrameFarm now has:
#   day, daily_frac, blue_ratio, visible_for_ratio,
#   farm_kg, farm_harvestable_berries, farm_green_on_bush, etc.

# ======================================================================
# 4) ECONOMICS: PRICE CURVE + FARM_HARVESTABLE_KG + POTENTIAL REVENUE
# ======================================================================

DataFrameFarmEconomics = DataFrameFarm.copy()

price = np.zeros(len(DataFrameFarmEconomics))


# Days 0–30: 10 → 9  (keep as is)
price[0:31] = np.linspace(10, 9, 31)

# Days 30–50: 9 → 7  (keep as is)
price[30:51] = np.linspace(9, 7, 21)

# ==== NEW: Days 50–90, more aggressive drop ====

# 50–80: almost flat, 7.0 → 6.8 (your 7, 6.99, 6.8, 6.7, etc. vibe)
price[50:81] = np.linspace(7.0, 6.8, 31)   # days 50..80

# 81–85: first PUMBA → drop from 6.8 to 4
price[81:86] = np.linspace(5, 4.0, 5)    # days 81..85

# 86–90: second PUMBA → drop from 4 to 3
price[86:91] = np.linspace(4.0, 3.0, 5)    # days 86..90


DataFrameFarmEconomics["price"] = price

print("Average price over the season:", DataFrameFarmEconomics["price"].mean())

# --- convert farm harvestable berries (counts) → kg ---
DataFrameFarmEconomics["farm_harvestable_kg"] = (
    DataFrameFarmEconomics["farm_harvestable_berries"] * (BERRY_WEIGHT_G / 1000)
)

# Potential revenue if you harvested all harvestable kg each day
DataFrameFarmEconomics["potential_revenue"] = (
    DataFrameFarmEconomics["farm_harvestable_kg"] * DataFrameFarmEconomics["price"]
)

# ======================================================================
# 5) MANUAL PICKERS: PARAMETERS & PER-KG ECONOMICS
# ======================================================================

kg_per_picker_per_hour = 4.0       # picker productivity
wage_per_hour = 20.0               # USD/hour
hours_per_day = 8
daily_cost_per_picker = wage_per_hour * hours_per_day  # 160 USD/day

MIN_PICKERS = 20
MAX_PICKERS = 600

material_cost_per_kg = 2.0         # packaging/materials per kg

# ======================================================================
# 6) MACHINE HARVEST: PARAMETERS & GREEN-LOSS PENALTY
# ======================================================================

kg_per_machine_per_hour = 4000.0   # machine throughput (kg/hour)
machine_fixed_cost = 1000.0        # fixed cost per day to run machine
GREEN_LOSS_FRAC = 0.8              # fraction of green berries destroyed if machine is used

# For green valuation we need green counts at farm level (kg)
DataFrameFarmEconomics["farm_green_kg"] = (
    DataFrameFarmEconomics["farm_green_on_bush"] * (BERRY_WEIGHT_G / 1000)
)

# ======================================================================
# 7) UNIFIED STATEFUL SIMULATION:
#    manual vs machine vs wait, with 1-day lookahead for the machine
# ======================================================================

n_days = len(DataFrameFarmEconomics)

# Arrays to store simulation results
dynamic_blue_kg = np.zeros(n_days)           # actual ripe kg on bush (state)
harvested_kg = np.zeros(n_days)              # what we actually harvest that day
action = np.array(["wait"] * n_days, dtype=object)  # "manual", "machine", "wait"

manual_profit_today = np.zeros(n_days)       # profit when we choose manual (else 0)
machine_profit_today = np.zeros(n_days)      # net machine profit when we choose machine (else 0)
realized_profit = np.zeros(n_days)           # profit actually realized that day

pickers_sent = np.zeros(n_days)
machine_used_flag = np.zeros(n_days, dtype=bool)

manual_revenue = np.zeros(n_days)
machine_revenue = np.zeros(n_days)
material_cost_used = np.zeros(n_days)
labor_cost_used = np.zeros(n_days)
machine_fixed_cost_used = np.zeros(n_days)
green_loss_kg_actual = np.zeros(n_days)
green_loss_value_actual = np.zeros(n_days)

net_machine_profit_after_green_loss = np.zeros(n_days)
net_profit_if_wait_one_day = np.zeros(n_days)

# For the machine's "new blue today" approximation we use theoretical 7-day window
theoretical_blue_series = DataFrameFarmEconomics["farm_harvestable_kg"].values

prev_dynamic_blue = 0.0
prev_theoretical_blue = 0.0

for t in range(n_days):
    price_today = DataFrameFarmEconomics.loc[t, "price"]
    green_kg_today = DataFrameFarmEconomics.loc[t, "farm_green_kg"]

    # --- theoretical harvestable (from ripening model) ---
    theoretical_blue_today = theoretical_blue_series[t]

    if t == 0:
        new_blue_today = theoretical_blue_today
    else:
        new_blue_today = max(theoretical_blue_today - prev_theoretical_blue, 0.0)

    # Dynamic ripe kg on bush today (carry over + new ripe)
    dynamic_blue_today = prev_dynamic_blue + new_blue_today
    dynamic_blue_kg[t] = dynamic_blue_today

    # If there is no ripe fruit, we cannot harvest
    if dynamic_blue_today <= 0:
        # nothing to harvest, everything stays
        prev_dynamic_blue = dynamic_blue_today
        prev_theoretical_blue = theoretical_blue_today
        continue

    # ------------------------------------------------------------------
    # MANUAL HARVEST OPTION (uses dynamic_blue_today)
    # ------------------------------------------------------------------
    required_pickers = dynamic_blue_today / (kg_per_picker_per_hour * hours_per_day)
    within_limits = (required_pickers >= MIN_PICKERS) and (required_pickers <= MAX_PICKERS)

    if within_limits:
        manual_rev = dynamic_blue_today * price_today
        manual_lab_cost = required_pickers * daily_cost_per_picker
        manual_mat_cost = dynamic_blue_today * material_cost_per_kg
        profit_manual = manual_rev - manual_lab_cost - manual_mat_cost
    else:
        manual_rev = 0.0
        manual_lab_cost = 0.0
        manual_mat_cost = 0.0
        profit_manual = -np.inf  # not allowed (too few or too many pickers)

    # ------------------------------------------------------------------
    # MACHINE HARVEST OPTION TODAY (with green-loss penalty)
    # ------------------------------------------------------------------
    next_price = DataFrameFarmEconomics.loc[min(t + 1, n_days - 1), "price"]

    machine_rev_today = dynamic_blue_today * price_today
    machine_mat_cost_today = dynamic_blue_today * material_cost_per_kg
    machine_profit_gross_today = machine_rev_today - machine_mat_cost_today - machine_fixed_cost

    green_loss_kg_today = GREEN_LOSS_FRAC * green_kg_today
    green_loss_value_today = green_loss_kg_today * next_price

    net_machine_today = machine_profit_gross_today - green_loss_value_today

    # ------------------------------------------------------------------
    # LOOKAHEAD: WHAT IF WE WAIT ONE DAY AND THEN USE MACHINE?
    # (approximation similar to your separate machine model)
    # ------------------------------------------------------------------
    if t == n_days - 1:
        # At the last day, "waiting" for machine makes no sense
        net_machine_if_wait = -1e12
    else:
        theoretical_blue_tomorrow = theoretical_blue_series[t + 1]
        new_blue_tomorrow = max(theoretical_blue_tomorrow - theoretical_blue_today, 0.0)
        dynamic_blue_tomorrow_if_wait = dynamic_blue_today + new_blue_tomorrow

        price_tomorrow = DataFrameFarmEconomics.loc[t + 1, "price"]

        machine_revenue_tomorrow = dynamic_blue_tomorrow_if_wait * price_tomorrow
        machine_material_cost_tomorrow = dynamic_blue_tomorrow_if_wait * material_cost_per_kg
        machine_profit_gross_tomorrow = (
            machine_revenue_tomorrow - machine_material_cost_tomorrow - machine_fixed_cost
        )

        green_kg_tomorrow = DataFrameFarmEconomics.loc[t + 1, "farm_green_kg"]
        next_next_price = DataFrameFarmEconomics.loc[min(t + 2, n_days - 1), "price"]
        green_loss_kg_tomorrow = GREEN_LOSS_FRAC * green_kg_tomorrow
        green_loss_value_tomorrow = green_loss_kg_tomorrow * next_next_price

        net_machine_if_wait = machine_profit_gross_tomorrow - green_loss_value_tomorrow

    net_machine_profit_after_green_loss[t] = net_machine_today
    net_profit_if_wait_one_day[t] = net_machine_if_wait

    # ------------------------------------------------------------------
    # DECISION LOGIC (UNIFIED):
    #   - Compare: manual vs machine today vs waiting.
    #   - Machine only if:
    #         net_machine_today > 0 AND
    #         net_machine_today >= net_machine_if_wait AND
    #         net_machine_today >= manual_profit
    #   - Manual only if:
    #         profit_manual > 0 AND
    #         profit_manual >= net_machine_today AND
    #         profit_manual >= 0 (obvious)
    #   - If both are bad or "waiting" is better, we do nothing today.
    # ------------------------------------------------------------------

    best_immediate = max(profit_manual, net_machine_today, 0.0)

    if best_immediate <= 0:
        # Neither option is attractive: we wait
        action[t] = "wait"
        harvested_kg[t] = 0.0
        realized_profit[t] = 0.0
        prev_dynamic_blue = dynamic_blue_today  # carry stock forward
    else:
        # Check if manual dominates
        if (profit_manual > 0) and (profit_manual >= net_machine_today) and (profit_manual >= 0):
            # MANUAL HARVEST
            action[t] = "manual"
            harvested_kg[t] = dynamic_blue_today
            realized_profit[t] = profit_manual

            pickers_sent[t] = required_pickers
            manual_profit_today[t] = profit_manual
            manual_revenue[t] = manual_rev
            labor_cost_used[t] = manual_lab_cost
            material_cost_used[t] = manual_mat_cost

            machine_profit_today[t] = 0.0
            machine_used_flag[t] = False
            machine_fixed_cost_used[t] = 0.0
            green_loss_kg_actual[t] = 0.0
            green_loss_value_actual[t] = 0.0

            prev_dynamic_blue = 0.0  # bush is cleaned of ripe fruit

        else:
            # Candidate: machine harvest, but respect lookahead rule
            if (net_machine_today > 0) and (net_machine_today >= net_machine_if_wait):
                # MACHINE HARVEST NOW
                action[t] = "machine"
                harvested_kg[t] = dynamic_blue_today
                realized_profit[t] = net_machine_today

                machine_used_flag[t] = True
                machine_profit_today[t] = net_machine_today
                machine_revenue[t] = machine_rev_today
                material_cost_used[t] = machine_mat_cost_today
                machine_fixed_cost_used[t] = machine_fixed_cost
                green_loss_kg_actual[t] = green_loss_kg_today
                green_loss_value_actual[t] = green_loss_value_today

                # no manual
                pickers_sent[t] = 0.0
                manual_profit_today[t] = 0.0
                labor_cost_used[t] = 0.0
                manual_revenue[t] = 0.0

                prev_dynamic_blue = 0.0  # bush is cleaned of ripe fruit

            else:
                # Even if machine looks good in isolation, waiting one day is better,
                # or both are not good enough → we wait.
                action[t] = "wait"
                harvested_kg[t] = 0.0
                realized_profit[t] = 0.0
                prev_dynamic_blue = dynamic_blue_today

    prev_theoretical_blue = theoretical_blue_today

# ======================================================================
# 8) ATTACH RESULTS TO A SINGLE "FARM_SIMULATION" DATAFRAME
# ======================================================================

FarmSimulation = DataFrameFarmEconomics.copy()

FarmSimulation["dynamic_blue_kg"] = dynamic_blue_kg
FarmSimulation["harvested_kg"] = harvested_kg
FarmSimulation["action"] = action
FarmSimulation["realized_profit"] = realized_profit

FarmSimulation["manual_profit_if_used"] = manual_profit_today
FarmSimulation["machine_profit_if_used"] = machine_profit_today

FarmSimulation["pickers_sent"] = pickers_sent
FarmSimulation["machine_used_today"] = machine_used_flag

FarmSimulation["manual_revenue"] = manual_revenue
FarmSimulation["machine_revenue"] = machine_revenue

FarmSimulation["material_cost_used"] = material_cost_used
FarmSimulation["labor_cost_used"] = labor_cost_used
FarmSimulation["machine_fixed_cost_used"] = machine_fixed_cost_used

FarmSimulation["green_loss_kg_actual"] = green_loss_kg_actual
FarmSimulation["green_loss_value_actual"] = green_loss_value_actual

FarmSimulation["net_machine_profit_after_green_loss_today"] = net_machine_profit_after_green_loss
FarmSimulation["net_profit_if_wait_one_day_machine"] = net_profit_if_wait_one_day

# Quick peek
print(FarmSimulation[["day", "price", "dynamic_blue_kg", "action",
                      "harvested_kg", "realized_profit"]].head(101))

# ======================================================================
# 9) SIMPLE PLOTS TO SEE WHEN EACH METHOD IS USED
# ======================================================================

fig, axes = plt.subplots(3, 1, figsize=(12, 12), sharex=True)

# --- where we harvest and with what ---
ax1 = axes[0]
ax1.plot(FarmSimulation["day"], FarmSimulation["dynamic_blue_kg"], label="Dynamic blue kg on bush")

mask_manual = FarmSimulation["action"] == "manual"
mask_machine = FarmSimulation["action"] == "machine"

ax1.scatter(FarmSimulation.loc[mask_manual, "day"],
            FarmSimulation.loc[mask_manual, "dynamic_blue_kg"],
            label="Manual harvest", marker="o")
ax1.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "dynamic_blue_kg"],
            label="Machine harvest", marker="x")

ax1.set_ylabel("Blue kg on bush")
ax1.set_title("Dynamic blue kg & harvest decisions")
ax1.legend()
ax1.grid(True)

# --- profit today vs profit if machine waits one day ---
ax2 = axes[1]
ax2.plot(FarmSimulation["day"],
         FarmSimulation["net_machine_profit_after_green_loss_today"],
         label="Net machine profit TODAY")
ax2.plot(FarmSimulation["day"],
         FarmSimulation["net_profit_if_wait_one_day_machine"],
         label="Net machine profit if WAIT 1 day")
ax2.axhline(0, linestyle="--")

ax2.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "net_machine_profit_after_green_loss_today"],
            label="Machine chosen", marker="x")

ax2.set_ylabel("Profit (USD)")
ax2.set_title("Machine: today vs wait one day")
ax2.legend()
ax2.grid(True)

# --- realized profit over season ---
ax3 = axes[2]
ax3.bar(FarmSimulation["day"], FarmSimulation["realized_profit"])
ax3.set_xlabel("Day")
ax3.set_ylabel("Realized profit (USD)")
ax3.set_title("Realized profit per day (manual or machine)")
ax3.grid(True)

plt.tight_layout()
plt.show()

# from google.colab import drive
# drive.mount('/content/drive')

FarmSimulation

FarmSimulation.to_excel("FarmSimulation.xlsx", index=False)

# from google.colab import drive
# drive.mount('/content/drive')

# ======================================================================
# BLUEBERRY FARM HARVEST SIMULATION (ONE-CELL VERSION, 50 DAYS)
# Ripening model + farm scaling + prices + unified manual vs machine logic
# ======================================================================

import numpy as np
import pandas as pd
from scipy.stats import lognorm
import matplotlib.pyplot as plt

# Make DataFrame print nicely (optional)
pd.set_option('display.float_format', lambda x: f'{x:,.2f}')

# ======================================================================
# 1) RIPENING MODEL (SINGLE PLANT, 50 DAYS, LEFT-SKEWED LOGNORMAL)
# ======================================================================

TOTAL_KG = 4.0               # total kg per plant in the season
BERRY_WEIGHT_G = 1.5         # grams per berry

TABLE_END_DAY = 50           # <<< simulate days 0..50 (51 days total)
HARVEST_LIFE_DAYS = 7        # a ripe berry is marketable for 7 days
GREEN_WINDOW_DAYS = 10       # "visible green" window before ripening

days = np.arange(TABLE_END_DAY + 1)  # 0..50

# --- left-skewed log-normal daily production fraction ---
# (params originally tuned for a ~90-day left-skew pattern; we keep them,
#  but now they are applied over 0..50 and then renormalized)
shape = 0.4132
scale = 23.34

right_skew = lognorm.pdf(days + 1, shape, scale=scale)
right_skew /= right_skew.sum()

left_skew = right_skew[::-1]
left_skew /= left_skew.sum()

daily_frac = left_skew  # fraction of the season’s production that appears each day

# --- convert fraction → kg and berries per day ---
kg_per_day = TOTAL_KG * daily_frac
total_berries = TOTAL_KG * 1000.0 / BERRY_WEIGHT_G
berries_per_day = total_berries * daily_frac

cum_kg = kg_per_day.cumsum()
remaining_kg = TOTAL_KG - cum_kg

cum_ripened = berries_per_day.cumsum()
remaining_berries = total_berries - cum_ripened

# --- harvestable (ripe) berries = last HARVEST_LIFE_DAYS ---
harvestable = []
for T in days:
    start = max(0, T - HARVEST_LIFE_DAYS + 1)
    end = T
    harvestable.append(berries_per_day[start:end+1].sum())
harvestable = np.array(harvestable)
lost_berries = cum_ripened - harvestable

# --- green berries that will ripen within GREEN_WINDOW_DAYS ---
green_on_bush = []
for T in days:
    start = T + 1
    end = min(T + GREEN_WINDOW_DAYS, TABLE_END_DAY)
    if start > end:
        green_on_bush.append(0.0)
    else:
        green_on_bush.append(berries_per_day[start:end+1].sum())
green_on_bush = np.array(green_on_bush)

visible_for_ratio = green_on_bush + harvestable

blue_ratio = []
for h, vis in zip(harvestable, visible_for_ratio):
    if vis == 0:
        blue_ratio.append(np.nan)
    else:
        blue_ratio.append(h / vis)

# --- base plant DataFrame ---
df = pd.DataFrame({
    "day": days,
    "daily_frac": daily_frac,
    "kg": kg_per_day,
    "cum_kg": cum_kg,
    "remaining_kg": remaining_kg,
    "berries_per_day": berries_per_day.astype(int),
    "harvestable_berries": harvestable.astype(int),
    "lost_berries": lost_berries.astype(int),
    "remaining_berries": remaining_berries.astype(int),
    "green_on_bush": green_on_bush.astype(int),
    "visible_for_ratio": visible_for_ratio.astype(int),
    "blue_ratio": np.round(blue_ratio, 3)
})

df["daily_frac"] = df["daily_frac"].round(6)
df["kg"] = df["kg"].round(4)
df["cum_kg"] = df["cum_kg"].round(4)
df["remaining_kg"] = df["remaining_kg"].round(4)

# ======================================================================
# 2) HOW MUCH OF THE CROP FALLS IN EACH THIRD OF THE SEASON? (50 DAYS)
# ======================================================================

total_berries_season = df["berries_per_day"].sum()

# For 51 days (0..50), natural split is 17 / 17 / 17
n_days_total = TABLE_END_DAY + 1  # 51
block = n_days_total // 3         # 17
# remainder = n_days_total % 3    # 0 here, so perfect thirds

# First third: days 0..16
first_mask = df["day"].between(0, block - 1)
# Second third: days 17..33
second_mask = df["day"].between(block, 2*block - 1)
# Third third: days 34..50
third_mask = df["day"].between(2*block, n_days_total - 1)

first_third = df.loc[first_mask, "berries_per_day"].sum()
second_third = df.loc[second_mask, "berries_per_day"].sum()
third_third = df.loc[third_mask, "berries_per_day"].sum()

pct_first = first_third / total_berries_season * 100
pct_second = second_third / total_berries_season * 100
pct_third = third_third / total_berries_season * 100

print("Distribution of berries in thirds of the (50-day) season:")
print(f"  First third (days 0–16) : {pct_first:5.1f}%")
print(f"  Second third (17–33)    : {pct_second:5.1f}%")
print(f"  Third third (34–50)     : {pct_third:5.1f}%")
print()

# ======================================================================
# 3) SCALE TO FARM LEVEL
# ======================================================================

plant_count = 12000

# columns that are counts or kg
cols_to_scale = [
    "kg",
    "cum_kg",
    "remaining_kg",
    "berries_per_day",
    "harvestable_berries",
    "lost_berries",
    "remaining_berries",
    "green_on_bush",
]

DataFrameFarm = df.copy()

for col in cols_to_scale:
    DataFrameFarm[col] = DataFrameFarm[col] * plant_count

# rename scaled columns with 'farm_' prefix
rename_map = {col: f"farm_{col}" for col in cols_to_scale}
DataFrameFarm = DataFrameFarm.rename(columns=rename_map)

# DataFrameFarm now has:
#   day, daily_frac, blue_ratio, visible_for_ratio,
#   farm_kg, farm_harvestable_berries, farm_green_on_bush, etc.

# ======================================================================
# 4) ECONOMICS: PRICE CURVE + FARM_HARVESTABLE_KG + POTENTIAL REVENUE
# ======================================================================

DataFrameFarmEconomics = DataFrameFarm.copy()

price = np.zeros(len(DataFrameFarmEconomics))

price[0:26] = np.linspace(10, 9, 26)

# Days 26–30: 9 → 8
# indices 26..30 (5 points)
price[26:31] = np.linspace(9, 8, 5)

# Days 31–39: flat at 4
# indices 31..39
price[31:40] = 4.0

# Days 40–50: 4 → 3
# indices 40..50 (11 points)
price[40:51] = np.linspace(4, 3, 11)

# No 50–90 section anymore because the season ends at day 50

DataFrameFarmEconomics["price"] = price

print("Average price over the (50-day) season:",
      DataFrameFarmEconomics["price"].mean())
print()

# --- convert farm harvestable berries (counts) → kg ---
DataFrameFarmEconomics["farm_harvestable_kg"] = (
    DataFrameFarmEconomics["farm_harvestable_berries"] * (BERRY_WEIGHT_G / 1000)
)

# Potential revenue if you harvested all harvestable kg each day
DataFrameFarmEconomics["potential_revenue"] = (
    DataFrameFarmEconomics["farm_harvestable_kg"] * DataFrameFarmEconomics["price"]
)

# ======================================================================
# 5) MANUAL PICKERS: PARAMETERS & PER-KG ECONOMICS
# ======================================================================

kg_per_picker_per_hour = 4.0       # picker productivity
wage_per_hour = 20.0               # USD/hour
hours_per_day = 8
daily_cost_per_picker = wage_per_hour * hours_per_day  # 160 USD/day

MIN_PICKERS = 20
MAX_PICKERS = 600

material_cost_per_kg = 2.0         # packaging/materials per kg

# ======================================================================
# 6) MACHINE HARVEST: PARAMETERS & GREEN-LOSS PENALTY
# ======================================================================

kg_per_machine_per_hour = 4000.0   # machine throughput (kg/hour)
machine_fixed_cost = 1000000.0        # fixed cost per day to run machine
GREEN_LOSS_FRAC = 0.10              # fraction of green berries destroyed if machine is used

# For green valuation we need green counts at farm level (kg)
DataFrameFarmEconomics["farm_green_kg"] = (
    DataFrameFarmEconomics["farm_green_on_bush"] * (BERRY_WEIGHT_G / 1000)
)

# ======================================================================
# 7) UNIFIED STATEFUL SIMULATION:
#    manual vs machine vs wait, with 1-day lookahead for the machine
# ======================================================================

n_days = len(DataFrameFarmEconomics)

# Arrays to store simulation results
dynamic_blue_kg = np.zeros(n_days)           # actual ripe kg on bush (state)
harvested_kg = np.zeros(n_days)              # what we actually harvest that day
action = np.array(["wait"] * n_days, dtype=object)  # "manual", "machine", "wait"

manual_profit_today = np.zeros(n_days)       # profit when we choose manual (else 0)
machine_profit_today = np.zeros(n_days)      # net machine profit when we choose machine (else 0)
realized_profit = np.zeros(n_days)           # profit actually realized that day

pickers_sent = np.zeros(n_days)
machine_used_flag = np.zeros(n_days, dtype=bool)

manual_revenue = np.zeros(n_days)
machine_revenue = np.zeros(n_days)
material_cost_used = np.zeros(n_days)
labor_cost_used = np.zeros(n_days)
machine_fixed_cost_used = np.zeros(n_days)
green_loss_kg_actual = np.zeros(n_days)
green_loss_value_actual = np.zeros(n_days)

net_machine_profit_after_green_loss = np.zeros(n_days)
net_profit_if_wait_one_day = np.zeros(n_days)

# For the machine's "new blue today" approximation we use theoretical 7-day window
theoretical_blue_series = DataFrameFarmEconomics["farm_harvestable_kg"].values

prev_dynamic_blue = 0.0
prev_theoretical_blue = 0.0

for t in range(n_days):
    price_today = DataFrameFarmEconomics.loc[t, "price"]
    green_kg_today = DataFrameFarmEconomics.loc[t, "farm_green_kg"]

    # --- theoretical harvestable (from ripening model) ---
    theoretical_blue_today = theoretical_blue_series[t]

    if t == 0:
        new_blue_today = theoretical_blue_today
    else:
        new_blue_today = max(theoretical_blue_today - prev_theoretical_blue, 0.0)

    # Dynamic ripe kg on bush today (carry over + new ripe)
    dynamic_blue_today = prev_dynamic_blue + new_blue_today
    dynamic_blue_kg[t] = dynamic_blue_today

    # If there is no ripe fruit, we cannot harvest
    if dynamic_blue_today <= 0:
        prev_dynamic_blue = dynamic_blue_today
        prev_theoretical_blue = theoretical_blue_today
        continue

    # ------------------------------------------------------------------
    # MANUAL HARVEST OPTION (uses dynamic_blue_today)
    # ------------------------------------------------------------------
    required_pickers = dynamic_blue_today / (kg_per_picker_per_hour * hours_per_day)
    within_limits = (required_pickers >= MIN_PICKERS) and (required_pickers <= MAX_PICKERS)

    if within_limits:
        manual_rev = dynamic_blue_today * price_today
        manual_lab_cost = required_pickers * daily_cost_per_picker
        manual_mat_cost = dynamic_blue_today * material_cost_per_kg
        profit_manual = manual_rev - manual_lab_cost - manual_mat_cost
    else:
        manual_rev = 0.0
        manual_lab_cost = 0.0
        manual_mat_cost = 0.0
        profit_manual = -np.inf  # not allowed (too few or too many pickers)

    # ------------------------------------------------------------------
    # MACHINE HARVEST OPTION TODAY (with green-loss penalty)
    # ------------------------------------------------------------------
    next_price = DataFrameFarmEconomics.loc[min(t + 1, n_days - 1), "price"]

    machine_rev_today = dynamic_blue_today * price_today
    machine_mat_cost_today = dynamic_blue_today * material_cost_per_kg
    machine_profit_gross_today = machine_rev_today - machine_mat_cost_today - machine_fixed_cost

    green_loss_kg_today = GREEN_LOSS_FRAC * green_kg_today
    green_loss_value_today = green_loss_kg_today * next_price

    net_machine_today = machine_profit_gross_today - green_loss_value_today

    # ------------------------------------------------------------------
    # LOOKAHEAD: WHAT IF WE WAIT ONE DAY AND THEN USE MACHINE?
    # ------------------------------------------------------------------
    if t == n_days - 1:
        net_machine_if_wait = -1e12
    else:
        theoretical_blue_tomorrow = theoretical_blue_series[t + 1]
        new_blue_tomorrow = max(theoretical_blue_tomorrow - theoretical_blue_today, 0.0)
        dynamic_blue_tomorrow_if_wait = dynamic_blue_today + new_blue_tomorrow

        price_tomorrow = DataFrameFarmEconomics.loc[t + 1, "price"]

        machine_revenue_tomorrow = dynamic_blue_tomorrow_if_wait * price_tomorrow
        machine_material_cost_tomorrow = dynamic_blue_tomorrow_if_wait * material_cost_per_kg
        machine_profit_gross_tomorrow = (
            machine_revenue_tomorrow - machine_material_cost_tomorrow - machine_fixed_cost
        )

        green_kg_tomorrow = DataFrameFarmEconomics.loc[t + 1, "farm_green_kg"]
        next_next_price = DataFrameFarmEconomics.loc[min(t + 2, n_days - 1), "price"]
        green_loss_kg_tomorrow = GREEN_LOSS_FRAC * green_kg_tomorrow
        green_loss_value_tomorrow = green_loss_kg_tomorrow * next_next_price

        net_machine_if_wait = machine_profit_gross_tomorrow - green_loss_value_tomorrow

    net_machine_profit_after_green_loss[t] = net_machine_today
    net_profit_if_wait_one_day[t] = net_machine_if_wait

    # ------------------------------------------------------------------
    # DECISION LOGIC (UNIFIED)
    # ------------------------------------------------------------------

    best_immediate = max(profit_manual, net_machine_today, 0.0)

    if best_immediate <= 0:
        # Neither option is attractive: we wait
        action[t] = "wait"
        harvested_kg[t] = 0.0
        realized_profit[t] = 0.0
        prev_dynamic_blue = dynamic_blue_today  # carry stock forward
    else:
        # Check if manual dominates
        if (profit_manual > 0) and (profit_manual >= net_machine_today) and (profit_manual >= 0):
            # MANUAL HARVEST
            action[t] = "manual"
            harvested_kg[t] = dynamic_blue_today
            realized_profit[t] = profit_manual

            pickers_sent[t] = required_pickers
            manual_profit_today[t] = profit_manual
            manual_revenue[t] = manual_rev
            labor_cost_used[t] = manual_lab_cost
            material_cost_used[t] = manual_mat_cost

            machine_profit_today[t] = 0.0
            machine_used_flag[t] = False
            machine_fixed_cost_used[t] = 0.0
            green_loss_kg_actual[t] = 0.0
            green_loss_value_actual[t] = 0.0

            prev_dynamic_blue = 0.0  # bush is cleaned of ripe fruit

        else:
            # Candidate: machine harvest, but respect lookahead rule
            if (net_machine_today > 0) and (net_machine_today >= net_machine_if_wait):
                # MACHINE HARVEST NOW
                action[t] = "machine"
                harvested_kg[t] = dynamic_blue_today
                realized_profit[t] = net_machine_today

                machine_used_flag[t] = True
                machine_profit_today[t] = net_machine_today
                machine_revenue[t] = machine_rev_today
                material_cost_used[t] = machine_mat_cost_today
                machine_fixed_cost_used[t] = machine_fixed_cost
                green_loss_kg_actual[t] = green_loss_kg_today
                green_loss_value_actual[t] = green_loss_value_today

                # no manual
                pickers_sent[t] = 0.0
                manual_profit_today[t] = 0.0
                labor_cost_used[t] = 0.0
                manual_revenue[t] = 0.0

                prev_dynamic_blue = 0.0  # bush is cleaned of ripe fruit

            else:
                # Waiting is better than harvesting now
                action[t] = "wait"
                harvested_kg[t] = 0.0
                realized_profit[t] = 0.0
                prev_dynamic_blue = dynamic_blue_today

    prev_theoretical_blue = theoretical_blue_today

# ======================================================================
# 8) ATTACH RESULTS TO A SINGLE "FARM_SIMULATION" DATAFRAME
# ======================================================================

FarmSimulation = DataFrameFarmEconomics.copy()

FarmSimulation["dynamic_blue_kg"] = dynamic_blue_kg
FarmSimulation["harvested_kg"] = harvested_kg
FarmSimulation["action"] = action
FarmSimulation["realized_profit"] = realized_profit

FarmSimulation["manual_profit_if_used"] = manual_profit_today
FarmSimulation["machine_profit_if_used"] = machine_profit_today

FarmSimulation["pickers_sent"] = pickers_sent
FarmSimulation["machine_used_today"] = machine_used_flag

FarmSimulation["manual_revenue"] = manual_revenue
FarmSimulation["machine_revenue"] = machine_revenue

FarmSimulation["material_cost_used"] = material_cost_used
FarmSimulation["labor_cost_used"] = labor_cost_used
FarmSimulation["machine_fixed_cost_used"] = machine_fixed_cost_used

FarmSimulation["green_loss_kg_actual"] = green_loss_kg_actual
FarmSimulation["green_loss_value_actual"] = green_loss_value_actual

FarmSimulation["net_machine_profit_after_green_loss_today"] = net_machine_profit_after_green_loss
FarmSimulation["net_profit_if_wait_one_day_machine"] = net_profit_if_wait_one_day

# Quick peek (will show all 51 days anyway)
print(FarmSimulation[["day", "price", "dynamic_blue_kg", "action",
                      "harvested_kg", "realized_profit"]].head(60))

# ======================================================================
# 9) SIMPLE PLOTS TO SEE WHEN EACH METHOD IS USED
# ======================================================================

fig, axes = plt.subplots(3, 1, figsize=(12, 12), sharex=True)

# --- where we harvest and with what ---
ax1 = axes[0]
ax1.plot(FarmSimulation["day"], FarmSimulation["dynamic_blue_kg"], label="Dynamic blue kg on bush")

mask_manual = FarmSimulation["action"] == "manual"
mask_machine = FarmSimulation["action"] == "machine"

ax1.scatter(FarmSimulation.loc[mask_manual, "day"],
            FarmSimulation.loc[mask_manual, "dynamic_blue_kg"],
            label="Manual harvest", marker="o")
ax1.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "dynamic_blue_kg"],
            label="Machine harvest", marker="x")

ax1.set_ylabel("Blue kg on bush")
ax1.set_title("Dynamic blue kg & harvest decisions")
ax1.legend()
ax1.grid(True)

# --- profit today vs profit if machine waits one day ---
ax2 = axes[1]
ax2.plot(FarmSimulation["day"],
         FarmSimulation["net_machine_profit_after_green_loss_today"],
         label="Net machine profit TODAY")
ax2.plot(FarmSimulation["day"],
         FarmSimulation["net_profit_if_wait_one_day_machine"],
         label="Net machine profit if WAIT 1 day")
ax2.axhline(0, linestyle="--")

ax2.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "net_machine_profit_after_green_loss_today"],
            label="Machine chosen", marker="x")

ax2.set_ylabel("Profit (USD)")
ax2.set_title("Machine: today vs wait one day")
ax2.legend()
ax2.grid(True)

# --- realized profit over season ---
ax3 = axes[2]
ax3.bar(FarmSimulation["day"], FarmSimulation["realized_profit"])
ax3.set_xlabel("Day")
ax3.set_ylabel("Realized profit (USD)")
ax3.set_title("Realized profit per day (manual or machine)")
ax3.grid(True)

plt.tight_layout()
plt.show()

# ======================================================================
# 7) UNIFIED STATEFUL SIMULATION:
#    manual vs machine vs wait, with 1-day lookahead for the machine
#    (dynamic_blue = prev + newly_ripe - overripe - harvested)
# ======================================================================

n_days = len(DataFrameFarmEconomics)

# Arrays to store simulation results
dynamic_blue_kg = np.zeros(n_days)           # actual ripe kg on bush (state)
harvested_kg = np.zeros(n_days)              # what we actually harvest that day
action = np.array(["wait"] * n_days, dtype=object)  # "manual", "machine", "wait"

manual_profit_today = np.zeros(n_days)       # profit when we choose manual (else 0)
machine_profit_today = np.zeros(n_days)      # net machine profit when we choose machine (else 0)
realized_profit = np.zeros(n_days)           # profit actually realized that day

pickers_sent = np.zeros(n_days)
machine_used_flag = np.zeros(n_days, dtype=bool)

manual_revenue = np.zeros(n_days)
machine_revenue = np.zeros(n_days)
material_cost_used = np.zeros(n_days)
labor_cost_used = np.zeros(n_days)
machine_fixed_cost_used = np.zeros(n_days)
green_loss_kg_actual = np.zeros(n_days)
green_loss_value_actual = np.zeros(n_days)

net_machine_profit_after_green_loss = np.zeros(n_days)
net_profit_if_wait_one_day = np.zeros(n_days)

# --- NEW: use daily flows instead of rolling-diff trick ---
farm_new_berries = DataFrameFarmEconomics["farm_berries_per_day"].values
berry_kg_factor = BERRY_WEIGHT_G / 1000.0

prev_dynamic_blue = 0.0  # ripe kg on bush at end of previous day

for t in range(n_days):
    price_today = DataFrameFarmEconomics.loc[t, "price"]
    green_kg_today = DataFrameFarmEconomics.loc[t, "farm_green_kg"]

    # --------------------------------------------------------------
    # 1) UPDATE INVENTORY OF RIPE (DYNAMIC BLUE) BEFORE HARVEST
    #    dynamic_blue_today = prev + newly_ripe - overripe
    # --------------------------------------------------------------
    newly_ripe_kg_today = farm_new_berries[t] * berry_kg_factor

    if t >= HARVEST_LIFE_DAYS:
        # berries that ripened HARVEST_LIFE_DAYS days ago now leave the "ripe" bucket
        overripe_kg_today = farm_new_berries[t - HARVEST_LIFE_DAYS] * berry_kg_factor
    else:
        overripe_kg_today = 0.0

    dynamic_blue_today = prev_dynamic_blue + newly_ripe_kg_today - overripe_kg_today
    if dynamic_blue_today < 0:
        dynamic_blue_today = 0.0

    dynamic_blue_kg[t] = dynamic_blue_today

    # If there is no ripe fruit, we cannot harvest
    if dynamic_blue_today <= 0:
        # carry forward whatever we have (0) and skip to next day
        prev_dynamic_blue = dynamic_blue_today
        continue

    # ------------------------------------------------------------------
    # 2) MANUAL HARVEST OPTION (uses dynamic_blue_today)
    # ------------------------------------------------------------------
    required_pickers = dynamic_blue_today / (kg_per_picker_per_hour * hours_per_day)
    within_limits = (required_pickers >= MIN_PICKERS) and (required_pickers <= MAX_PICKERS)

    if within_limits:
        manual_rev = dynamic_blue_today * price_today
        manual_lab_cost = required_pickers * daily_cost_per_picker
        manual_mat_cost = dynamic_blue_today * material_cost_per_kg
        profit_manual = manual_rev - manual_lab_cost - manual_mat_cost
    else:
        manual_rev = 0.0
        manual_lab_cost = 0.0
        manual_mat_cost = 0.0
        profit_manual = -np.inf  # not allowed (too few or too many pickers)

    # ------------------------------------------------------------------
    # 3) MACHINE HARVEST OPTION TODAY (with green-loss penalty)
    # ------------------------------------------------------------------
    next_price = DataFrameFarmEconomics.loc[min(t + 1, n_days - 1), "price"]

    machine_rev_today = dynamic_blue_today * price_today
    machine_mat_cost_today = dynamic_blue_today * material_cost_per_kg
    machine_profit_gross_today = machine_rev_today - machine_mat_cost_today - machine_fixed_cost

    green_loss_kg_today = GREEN_LOSS_FRAC * green_kg_today
    green_loss_value_today = green_loss_kg_today * next_price

    net_machine_today = machine_profit_gross_today - green_loss_value_today

    # ------------------------------------------------------------------
    # 4) LOOKAHEAD: WHAT IF WE WAIT ONE DAY AND THEN USE MACHINE?
    #    (we propagate dynamic_blue with same flow logic)
    # ------------------------------------------------------------------
    if t == n_days - 1:
        # At the last day, "waiting" for machine makes no sense
        net_machine_if_wait = -1e12
    else:
        newly_ripe_kg_tomorrow = farm_new_berries[t + 1] * berry_kg_factor
        if (t + 1) >= HARVEST_LIFE_DAYS:
            overripe_kg_tomorrow = farm_new_berries[t + 1 - HARVEST_LIFE_DAYS] * berry_kg_factor
        else:
            overripe_kg_tomorrow = 0.0

        # If we WAIT today, we do not harvest, so inventory tomorrow is:
        dynamic_blue_tomorrow_if_wait = dynamic_blue_today + newly_ripe_kg_tomorrow - overripe_kg_tomorrow
        if dynamic_blue_tomorrow_if_wait < 0:
            dynamic_blue_tomorrow_if_wait = 0.0

        price_tomorrow = DataFrameFarmEconomics.loc[t + 1, "price"]

        machine_revenue_tomorrow = dynamic_blue_tomorrow_if_wait * price_tomorrow
        machine_material_cost_tomorrow = dynamic_blue_tomorrow_if_wait * material_cost_per_kg
        machine_profit_gross_tomorrow = (
            machine_revenue_tomorrow - machine_material_cost_tomorrow - machine_fixed_cost
        )

        green_kg_tomorrow = DataFrameFarmEconomics.loc[t + 1, "farm_green_kg"]
        next_next_price = DataFrameFarmEconomics.loc[min(t + 2, n_days - 1), "price"]
        green_loss_kg_tomorrow = GREEN_LOSS_FRAC * green_kg_tomorrow
        green_loss_value_tomorrow = green_loss_kg_tomorrow * next_next_price

        net_machine_if_wait = machine_profit_gross_tomorrow - green_loss_value_tomorrow

    net_machine_profit_after_green_loss[t] = net_machine_today
    net_profit_if_wait_one_day[t] = net_machine_if_wait

    # ------------------------------------------------------------------
    # 5) DECISION LOGIC (UNIFIED)
    #    Compare manual vs machine today vs waiting.
    # ------------------------------------------------------------------

    best_immediate = max(profit_manual, net_machine_today, 0.0)

    if best_immediate <= 0:
        # Neither option is attractive: we wait
        action[t] = "wait"
        harvested_kg[t] = 0.0
        realized_profit[t] = 0.0

        # We did not harvest, so inventory carries forward
        prev_dynamic_blue = dynamic_blue_today

    else:
        # Check if manual dominates
        if (profit_manual > 0) and (profit_manual >= net_machine_today) and (profit_manual >= 0):
            # MANUAL HARVEST
            action[t] = "manual"
            harvested_kg[t] = dynamic_blue_today      # we pick everything
            realized_profit[t] = profit_manual

            pickers_sent[t] = required_pickers
            manual_profit_today[t] = profit_manual
            manual_revenue[t] = manual_rev
            labor_cost_used[t] = manual_lab_cost
            material_cost_used[t] = manual_mat_cost

            machine_profit_today[t] = 0.0
            machine_used_flag[t] = False
            machine_fixed_cost_used[t] = 0.0
            green_loss_kg_actual[t] = 0.0
            green_loss_value_actual[t] = 0.0

            # After harvest, ripe inventory is zero
            prev_dynamic_blue = dynamic_blue_today - harvested_kg[t]

        else:
            # Candidate: machine harvest, but respect lookahead rule
            if (net_machine_today > 0) and (net_machine_today >= net_machine_if_wait):
                # MACHINE HARVEST NOW
                action[t] = "machine"
                harvested_kg[t] = dynamic_blue_today   # machine also clears the bush
                realized_profit[t] = net_machine_today

                machine_used_flag[t] = True
                machine_profit_today[t] = net_machine_today
                machine_revenue[t] = machine_rev_today
                material_cost_used[t] = machine_mat_cost_today
                machine_fixed_cost_used[t] = machine_fixed_cost
                green_loss_kg_actual[t] = green_loss_kg_today
                green_loss_value_actual[t] = green_loss_value_today

                # no manual
                pickers_sent[t] = 0.0
                manual_profit_today[t] = 0.0
                labor_cost_used[t] = 0.0
                manual_revenue[t] = 0.0

                # After machine harvest, ripe inventory is zero
                prev_dynamic_blue = dynamic_blue_today - harvested_kg[t]

            else:
                # Waiting is better than harvesting now
                action[t] = "wait"
                harvested_kg[t] = 0.0
                realized_profit[t] = 0.0

                # we keep the ripe inventory on the bush
                prev_dynamic_blue = dynamic_blue_today

# ======================================================================
# 8) ATTACH RESULTS TO A SINGLE "FARM_SIMULATION" DATAFRAME
# ======================================================================

FarmSimulation = DataFrameFarmEconomics.copy()

FarmSimulation["dynamic_blue_kg"] = dynamic_blue_kg
FarmSimulation["harvested_kg"] = harvested_kg
FarmSimulation["action"] = action
FarmSimulation["realized_profit"] = realized_profit

FarmSimulation["manual_profit_if_used"] = manual_profit_today
FarmSimulation["machine_profit_if_used"] = machine_profit_today

FarmSimulation["pickers_sent"] = pickers_sent
FarmSimulation["machine_used_today"] = machine_used_flag

FarmSimulation["manual_revenue"] = manual_revenue
FarmSimulation["machine_revenue"] = machine_revenue

FarmSimulation["material_cost_used"] = material_cost_used
FarmSimulation["labor_cost_used"] = labor_cost_used
FarmSimulation["machine_fixed_cost_used"] = machine_fixed_cost_used

FarmSimulation["green_loss_kg_actual"] = green_loss_kg_actual
FarmSimulation["green_loss_value_actual"] = green_loss_value_actual

FarmSimulation["net_machine_profit_after_green_loss_today"] = net_machine_profit_after_green_loss
FarmSimulation["net_profit_if_wait_one_day_machine"] = net_profit_if_wait_one_day

# Quick peek – show the whole season (50 days) with key columns
print(
    FarmSimulation[
        ["day", "price", "dynamic_blue_kg", "action",
         "harvested_kg", "realized_profit"]
    ]
)

# ======================================================================
# 9) SIMPLE PLOTS TO SEE INVENTORY, DECISIONS, AND PROFIT
# ======================================================================

fig, axes = plt.subplots(3, 1, figsize=(12, 12), sharex=True)

# --- 1) Dynamic blue + harvest decisions ---
ax1 = axes[0]
ax1.plot(FarmSimulation["day"], FarmSimulation["dynamic_blue_kg"],
         label="Dynamic blue kg on bush")

mask_manual = FarmSimulation["action"] == "manual"
mask_machine = FarmSimulation["action"] == "machine"

ax1.scatter(FarmSimulation.loc[mask_manual, "day"],
            FarmSimulation.loc[mask_manual, "dynamic_blue_kg"],
            label="Manual harvest", marker="o")
ax1.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "dynamic_blue_kg"],
            label="Machine harvest", marker="x")

ax1.set_ylabel("Blue kg on bush")
ax1.set_title("Dynamic blue kg & harvest decisions")
ax1.legend()
ax1.grid(True)

# --- 2) Price and machine profit signals (optional but useful) ---
ax2 = axes[1]
ax2.plot(FarmSimulation["day"],
         FarmSimulation["price"],
         label="Price (USD/kg)")
ax2.set_ylabel("Price")
ax2.set_title("Price curve")
ax2.grid(True)

# --- 3) Realized profit over season ---
ax3 = axes[2]
ax3.bar(FarmSimulation["day"], FarmSimulation["realized_profit"])
ax3.set_xlabel("Day")
ax3.set_ylabel("Realized profit (USD)")
ax3.set_title("Realized profit per day (manual or machine)")
ax3.grid(True)

plt.tight_layout()
plt.show()

# ======================================================================
# BLUEBERRY FARM HARVEST SIMULATION (ONE-CELL VERSION, 50 DAYS)
# Ripening model + farm scaling + prices + unified manual vs machine logic
# with dynamic_blue = prev + newly_ripe - overripe - harvested
# ======================================================================

import numpy as np
import pandas as pd
from scipy.stats import lognorm
import matplotlib.pyplot as plt

# Make DataFrame print nicely (optional)
pd.set_option('display.float_format', lambda x: f'{x:,.2f}')

# ======================================================================
# 1) RIPENING MODEL (SINGLE PLANT, 50 DAYS, LEFT-SKEWED LOGNORMAL)
# ======================================================================

TOTAL_KG = 4.0               # total kg per plant in the season
BERRY_WEIGHT_G = 1.5         # grams per berry

TABLE_END_DAY = 50           # simulate days 0..50 (51 days total)
HARVEST_LIFE_DAYS = 7        # a ripe berry is marketable for 7 days
GREEN_WINDOW_DAYS = 10       # "visible green" window before ripening

days = np.arange(TABLE_END_DAY + 1)  # 0..50

# --- left-skewed log-normal daily production fraction tuned for 15/60/25 thirds ---
shape = 0.4132
scale = 23.34

right_skew = lognorm.pdf(days + 1, shape, scale=scale)
right_skew /= right_skew.sum()

left_skew = right_skew[::-1]
left_skew /= left_skew.sum()

daily_frac = left_skew  # fraction of the season’s production that appears each day

# --- convert fraction → kg and berries per day ---
kg_per_day = TOTAL_KG * daily_frac
total_berries = TOTAL_KG * 1000.0 / BERRY_WEIGHT_G
berries_per_day = total_berries * daily_frac

cum_kg = kg_per_day.cumsum()
remaining_kg = TOTAL_KG - cum_kg

cum_ripened = berries_per_day.cumsum()
remaining_berries = total_berries - cum_ripened

# --- harvestable (ripe) berries = last HARVEST_LIFE_DAYS ---
harvestable = []
for T in days:
    start = max(0, T - HARVEST_LIFE_DAYS + 1)
    end = T
    harvestable.append(berries_per_day[start:end+1].sum())
harvestable = np.array(harvestable)
lost_berries = cum_ripened - harvestable

# --- green berries that will ripen within GREEN_WINDOW_DAYS ---
green_on_bush = []
for T in days:
    start = T + 1
    end = min(T + GREEN_WINDOW_DAYS, TABLE_END_DAY)
    if start > end:
        green_on_bush.append(0.0)
    else:
        green_on_bush.append(berries_per_day[start:end+1].sum())
green_on_bush = np.array(green_on_bush)

visible_for_ratio = green_on_bush + harvestable

blue_ratio = []
for h, vis in zip(harvestable, visible_for_ratio):
    if vis == 0:
        blue_ratio.append(np.nan)
    else:
        blue_ratio.append(h / vis)

# --- base plant DataFrame ---
df = pd.DataFrame({
    "day": days,
    "daily_frac": daily_frac,
    "kg": kg_per_day,
    "cum_kg": cum_kg,
    "remaining_kg": remaining_kg,
    "berries_per_day": berries_per_day.astype(int),
    "harvestable_berries": harvestable.astype(int),
    "lost_berries": lost_berries.astype(int),
    "remaining_berries": remaining_berries.astype(int),
    "green_on_bush": green_on_bush.astype(int),
    "visible_for_ratio": visible_for_ratio.astype(int),
    "blue_ratio": np.round(blue_ratio, 3)
})

df["daily_frac"] = df["daily_frac"].round(6)
df["kg"] = df["kg"].round(4)
df["cum_kg"] = df["cum_kg"].round(4)
df["remaining_kg"] = df["remaining_kg"].round(4)

# ======================================================================
# 2) HOW MUCH OF THE CROP FALLS IN EACH THIRD OF THE SEASON? (50 DAYS)
# ======================================================================

total_berries_season = df["berries_per_day"].sum()

n_days_total = TABLE_END_DAY + 1  # 51
block = n_days_total // 3         # 17

first_mask = df["day"].between(0, block - 1)            # 0..16
second_mask = df["day"].between(block, 2*block - 1)     # 17..33
third_mask = df["day"].between(2*block, n_days_total - 1)  # 34..50

first_third = df.loc[first_mask, "berries_per_day"].sum()
second_third = df.loc[second_mask, "berries_per_day"].sum()
third_third = df.loc[third_mask, "berries_per_day"].sum()

pct_first = first_third / total_berries_season * 100
pct_second = second_third / total_berries_season * 100
pct_third = third_third / total_berries_season * 100

print("Distribution of berries in thirds of the (50-day) season:")
print(f"  First third (days 0–16) : {pct_first:5.1f}%")
print(f"  Second third (17–33)    : {pct_second:5.1f}%")
print(f"  Third third (34–50)     : {pct_third:5.1f}%")
print()

# ======================================================================
# 3) SCALE TO FARM LEVEL
# ======================================================================

plant_count = 12000

cols_to_scale = [
    "kg",
    "cum_kg",
    "remaining_kg",
    "berries_per_day",
    "harvestable_berries",
    "lost_berries",
    "remaining_berries",
    "green_on_bush",
]

DataFrameFarm = df.copy()

for col in cols_to_scale:
    DataFrameFarm[col] = DataFrameFarm[col] * plant_count

rename_map = {col: f"farm_{col}" for col in cols_to_scale}
DataFrameFarm = DataFrameFarm.rename(columns=rename_map)

# ======================================================================
# 4) ECONOMICS: PRICE CURVE + FARM_HARVESTABLE_KG + POTENTIAL REVENUE
# ======================================================================

DataFrameFarmEconomics = DataFrameFarm.copy()

price = np.zeros(len(DataFrameFarmEconomics))

# Days 0–5: 15 → 10  (6 points: 0..5)
price[0:6] = np.linspace(15, 10, 6)

# Days 6–10: 10 → 9  (5 points: 6..10)
price[6:11] = np.linspace(10, 9, 5)

# Days 11–20: 8 → 7  (10 points: 11..20)
price[11:21] = np.linspace(8, 7, 10)

# Days 21–30: 6 → 5  (10 points: 21..30)
price[21:31] = np.linspace(6, 5, 10)

# Days 31–50: flat at 4  (31..50)
price[31:51] = 4.0

DataFrameFarmEconomics["price"] = price

print("Average price over the (50-day) season:",
      DataFrameFarmEconomics["price"].mean())
print()

# harvestable berries → kg
DataFrameFarmEconomics["farm_harvestable_kg"] = (
    DataFrameFarmEconomics["farm_harvestable_berries"] * (BERRY_WEIGHT_G / 1000)
)

DataFrameFarmEconomics["potential_revenue"] = (
    DataFrameFarmEconomics["farm_harvestable_kg"] * DataFrameFarmEconomics["price"]
)

# ======================================================================
# 5) MANUAL PICKERS: PARAMETERS & PER-KG ECONOMICS
# ======================================================================

kg_per_picker_per_hour = 4.0       # picker productivity
wage_per_hour = 20.0               # USD/hour
hours_per_day = 8
daily_cost_per_picker = wage_per_hour * hours_per_day  # 160 USD/day

MIN_PICKERS = 20
MAX_PICKERS = 600

material_cost_per_kg = 2.0         # packaging/materials per kg

# ======================================================================
# 6) MACHINE HARVEST: PARAMETERS & GREEN-LOSS PENALTY
# ======================================================================

kg_per_machine_per_hour = 4000.0     # machine throughput (kg/hour)
machine_fixed_cost = 100.0     # fixed cost per day to run machine (huge on purpose)
GREEN_LOSS_FRAC = 0.60


               # fraction of green berries destroyed if machine is used

DataFrameFarmEconomics["farm_green_kg"] = (
    DataFrameFarmEconomics["farm_green_on_bush"] * (BERRY_WEIGHT_G / 1000)
)

# ======================================================================
# 7) UNIFIED STATEFUL SIMULATION:
#    manual vs machine vs wait, with 1-day lookahead for the machine
#    *** dynamic_blue = prev + newly_ripe - overripe - harvested ***
# ======================================================================

n_days = len(DataFrameFarmEconomics)

dynamic_blue_kg = np.zeros(n_days)
harvested_kg = np.zeros(n_days)
action = np.array(["wait"] * n_days, dtype=object)

manual_profit_today = np.zeros(n_days)
machine_profit_today = np.zeros(n_days)
realized_profit = np.zeros(n_days)

pickers_sent = np.zeros(n_days)
machine_used_flag = np.zeros(n_days, dtype=bool)

manual_revenue = np.zeros(n_days)
machine_revenue = np.zeros(n_days)
material_cost_used = np.zeros(n_days)
labor_cost_used = np.zeros(n_days)
machine_fixed_cost_used = np.zeros(n_days)
green_loss_kg_actual = np.zeros(n_days)
green_loss_value_actual = np.zeros(n_days)

net_machine_profit_after_green_loss = np.zeros(n_days)
net_profit_if_wait_one_day = np.zeros(n_days)

# NEW: use daily flows
farm_new_berries = DataFrameFarmEconomics["farm_berries_per_day"].values
berry_kg_factor = BERRY_WEIGHT_G / 1000.0

prev_dynamic_blue = 0.0  # ripe kg on bush at end of previous day

for t in range(n_days):
    price_today = DataFrameFarmEconomics.loc[t, "price"]
    green_kg_today = DataFrameFarmEconomics.loc[t, "farm_green_kg"]

    # --------------------------------------------------------------
    # 1) update ripe inventory BEFORE harvest
    #    dynamic_blue_today = prev + newly_ripe - overripe
    # --------------------------------------------------------------
    newly_ripe_kg_today = farm_new_berries[t] * berry_kg_factor

    if t >= HARVEST_LIFE_DAYS:
        overripe_kg_today = farm_new_berries[t - HARVEST_LIFE_DAYS] * berry_kg_factor
    else:
        overripe_kg_today = 0.0

    dynamic_blue_today = prev_dynamic_blue + newly_ripe_kg_today - overripe_kg_today
    if dynamic_blue_today < 0:
        dynamic_blue_today = 0.0

    dynamic_blue_kg[t] = dynamic_blue_today

    if dynamic_blue_today <= 0:
        prev_dynamic_blue = dynamic_blue_today
        continue

    # ------------------------------------------------------------------
    # 2) MANUAL HARVEST OPTION
    # ------------------------------------------------------------------
    required_pickers = dynamic_blue_today / (kg_per_picker_per_hour * hours_per_day)
    within_limits = (required_pickers >= MIN_PICKERS) and (required_pickers <= MAX_PICKERS)

    if within_limits:
        manual_rev = dynamic_blue_today * price_today
        manual_lab_cost = required_pickers * daily_cost_per_picker
        manual_mat_cost = dynamic_blue_today * material_cost_per_kg
        profit_manual = manual_rev - manual_lab_cost - manual_mat_cost
    else:
        manual_rev = 0.0
        manual_lab_cost = 0.0
        manual_mat_cost = 0.0
        profit_manual = -np.inf

    # ------------------------------------------------------------------
    # 3) MACHINE HARVEST OPTION TODAY (with green-loss penalty)
    # ------------------------------------------------------------------
    next_price = DataFrameFarmEconomics.loc[min(t + 1, n_days - 1), "price"]

    machine_rev_today = dynamic_blue_today * price_today
    machine_mat_cost_today = dynamic_blue_today * material_cost_per_kg
    machine_profit_gross_today = machine_rev_today - machine_mat_cost_today - machine_fixed_cost

    green_loss_kg_today = GREEN_LOSS_FRAC * green_kg_today
    green_loss_value_today = green_loss_kg_today * next_price

    net_machine_today = machine_profit_gross_today - green_loss_value_today

    # ------------------------------------------------------------------
    # 4) LOOKAHEAD: WHAT IF WE WAIT ONE DAY AND THEN USE MACHINE?
    # ------------------------------------------------------------------
    if t == n_days - 1:
        net_machine_if_wait = -1e12
    else:
        newly_ripe_kg_tomorrow = farm_new_berries[t + 1] * berry_kg_factor
        if (t + 1) >= HARVEST_LIFE_DAYS:
            overripe_kg_tomorrow = farm_new_berries[t + 1 - HARVEST_LIFE_DAYS] * berry_kg_factor
        else:
            overripe_kg_tomorrow = 0.0

        dynamic_blue_tomorrow_if_wait = (
            dynamic_blue_today + newly_ripe_kg_tomorrow - overripe_kg_tomorrow
        )
        if dynamic_blue_tomorrow_if_wait < 0:
            dynamic_blue_tomorrow_if_wait = 0.0

        price_tomorrow = DataFrameFarmEconomics.loc[t + 1, "price"]

        machine_revenue_tomorrow = dynamic_blue_tomorrow_if_wait * price_tomorrow
        machine_material_cost_tomorrow = dynamic_blue_tomorrow_if_wait * material_cost_per_kg
        machine_profit_gross_tomorrow = (
            machine_revenue_tomorrow - machine_material_cost_tomorrow - machine_fixed_cost
        )

        green_kg_tomorrow = DataFrameFarmEconomics.loc[t + 1, "farm_green_kg"]
        next_next_price = DataFrameFarmEconomics.loc[min(t + 2, n_days - 1), "price"]
        green_loss_kg_tomorrow = GREEN_LOSS_FRAC * green_kg_tomorrow
        green_loss_value_tomorrow = green_loss_kg_tomorrow * next_next_price

        net_machine_if_wait = machine_profit_gross_tomorrow - green_loss_value_tomorrow

    net_machine_profit_after_green_loss[t] = net_machine_today
    net_profit_if_wait_one_day[t] = net_machine_if_wait

    # ------------------------------------------------------------------
    # 5) DECISION LOGIC
    # ------------------------------------------------------------------
    best_immediate = max(profit_manual, net_machine_today, 0.0)

    if best_immediate <= 0:
        action[t] = "wait"
        harvested_kg[t] = 0.0
        realized_profit[t] = 0.0
        prev_dynamic_blue = dynamic_blue_today

    else:
        # manual dominates
        if (profit_manual > 0) and (profit_manual >= net_machine_today):
            action[t] = "manual"
            harvested_kg[t] = dynamic_blue_today
            realized_profit[t] = profit_manual

            pickers_sent[t] = required_pickers
            manual_profit_today[t] = profit_manual
            manual_revenue[t] = manual_rev
            labor_cost_used[t] = manual_lab_cost
            material_cost_used[t] = manual_mat_cost

            machine_profit_today[t] = 0.0
            machine_used_flag[t] = False
            machine_fixed_cost_used[t] = 0.0
            green_loss_kg_actual[t] = 0.0
            green_loss_value_actual[t] = 0.0

            prev_dynamic_blue = dynamic_blue_today - harvested_kg[t]

        else:
            if (net_machine_today > 0) and (net_machine_today >= net_machine_if_wait):
                action[t] = "machine"
                harvested_kg[t] = dynamic_blue_today
                realized_profit[t] = net_machine_today

                machine_used_flag[t] = True
                machine_profit_today[t] = net_machine_today
                machine_revenue[t] = machine_rev_today
                material_cost_used[t] = machine_mat_cost_today
                machine_fixed_cost_used[t] = machine_fixed_cost
                green_loss_kg_actual[t] = green_loss_kg_today
                green_loss_value_actual[t] = green_loss_value_today

                pickers_sent[t] = 0.0
                manual_profit_today[t] = 0.0
                labor_cost_used[t] = 0.0
                manual_revenue[t] = 0.0

                prev_dynamic_blue = dynamic_blue_today - harvested_kg[t]

            else:
                action[t] = "wait"
                harvested_kg[t] = 0.0
                realized_profit[t] = 0.0
                prev_dynamic_blue = dynamic_blue_today

# ======================================================================
# 8) ATTACH RESULTS TO A SINGLE "FARM_SIMULATION" DATAFRAME
# ======================================================================

FarmSimulation = DataFrameFarmEconomics.copy()

FarmSimulation["dynamic_blue_kg"] = dynamic_blue_kg
FarmSimulation["harvested_kg"] = harvested_kg
FarmSimulation["action"] = action
FarmSimulation["realized_profit"] = realized_profit

FarmSimulation["manual_profit_if_used"] = manual_profit_today
FarmSimulation["machine_profit_if_used"] = machine_profit_today

FarmSimulation["pickers_sent"] = pickers_sent
FarmSimulation["machine_used_today"] = machine_used_flag

FarmSimulation["manual_revenue"] = manual_revenue
FarmSimulation["machine_revenue"] = machine_revenue

FarmSimulation["material_cost_used"] = material_cost_used
FarmSimulation["labor_cost_used"] = labor_cost_used
FarmSimulation["machine_fixed_cost_used"] = machine_fixed_cost_used

FarmSimulation["green_loss_kg_actual"] = green_loss_kg_actual
FarmSimulation["green_loss_value_actual"] = green_loss_value_actual

FarmSimulation["net_machine_profit_after_green_loss_today"] = net_machine_profit_after_green_loss
FarmSimulation["net_profit_if_wait_one_day_machine"] = net_profit_if_wait_one_day

print(FarmSimulation[["day", "price", "dynamic_blue_kg", "action",
                      "harvested_kg", "realized_profit"]])

# ======================================================================
# 9) SIMPLE PLOTS TO SEE WHEN EACH METHOD IS USED
# ======================================================================

fig, axes = plt.subplots(3, 1, figsize=(12, 12), sharex=True)

# 1) Dynamic blue + harvest decisions
ax1 = axes[0]
ax1.plot(FarmSimulation["day"], FarmSimulation["dynamic_blue_kg"],
         label="Dynamic blue kg on bush")

mask_manual = FarmSimulation["action"] == "manual"
mask_machine = FarmSimulation["action"] == "machine"

ax1.scatter(FarmSimulation.loc[mask_manual, "day"],
            FarmSimulation.loc[mask_manual, "dynamic_blue_kg"],
            label="Manual harvest", marker="o")
ax1.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "dynamic_blue_kg"],
            label="Machine harvest", marker="x")

ax1.set_ylabel("Blue kg on bush")
ax1.set_title("Dynamic blue kg & harvest decisions")
ax1.legend()
ax1.grid(True)

# 2) Price curve
ax2 = axes[1]
ax2.plot(FarmSimulation["day"], FarmSimulation["price"], label="Price (USD/kg)")
ax2.set_ylabel("Price")
ax2.set_title("Price curve")
ax2.grid(True)

# 3) Realized profit
ax3 = axes[2]
ax3.bar(FarmSimulation["day"], FarmSimulation["realized_profit"])
ax3.set_xlabel("Day")
ax3.set_ylabel("Realized profit (USD)")
ax3.set_title("Realized profit per day (manual or machine)")
ax3.grid(True)

plt.tight_layout()
plt.show()

# 1) Dynamic blue + harvest decisions
plt.figure(figsize=(12, 4))
plt.plot(FarmSimulation["day"], FarmSimulation["dynamic_blue_kg"],
         label="Dynamic blue kg on bush")

mask_manual = FarmSimulation["action"] == "manual"
mask_machine = FarmSimulation["action"] == "machine"

plt.scatter(FarmSimulation.loc[mask_manual, "day"],
            FarmSimulation.loc[mask_manual, "dynamic_blue_kg"],
            label="Manual harvest", marker="o")
plt.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "dynamic_blue_kg"],
            label="Machine harvest", marker="x")

plt.ylabel("Blue kg on bush")
plt.title("Dynamic blue kg & harvest decisions")
plt.legend()
plt.grid(True)
plt.show()

# 2) Price curve
plt.figure(figsize=(12, 4))
plt.plot(FarmSimulation["day"], FarmSimulation["price"], label="Price (USD/kg)")
plt.ylabel("Price")
plt.title("Price curve")
plt.grid(True)
plt.show()

# 3) Realized profit
plt.figure(figsize=(12, 4))
plt.bar(FarmSimulation["day"], FarmSimulation["realized_profit"])
plt.xlabel("Day")
plt.ylabel("Realized profit (USD)")
plt.title("Realized profit per day (manual or machine)")
plt.grid(True)
plt.show()

# ======================================================================
# BLUEBERRY FARM HARVEST SIMULATION (ONE-CELL VERSION, 50 DAYS)
# Ripening model + farm scaling + prices + unified manual vs machine logic
# with dynamic_blue = prev + newly_ripe - overripe - harvested
# ======================================================================

import numpy as np
import pandas as pd
from scipy.stats import lognorm
import matplotlib.pyplot as plt

# Make DataFrame print nicely (optional)
pd.set_option('display.float_format', lambda x: f'{x:,.2f}')

# ======================================================================
# 1) RIPENING MODEL (SINGLE PLANT, 50 DAYS, LEFT-SKEWED LOGNORMAL)
# ======================================================================

TOTAL_KG = 4.0               # total kg per plant in the season
BERRY_WEIGHT_G = 1.5         # grams per berry

TABLE_END_DAY = 50           # simulate days 0..50 (51 days total)
HARVEST_LIFE_DAYS = 7        # a ripe berry is marketable for 7 days
GREEN_WINDOW_DAYS = 10       # "visible green" window before ripening

days = np.arange(TABLE_END_DAY + 1)  # 0..50

# --- left-skewed log-normal daily production fraction tuned for 15/60/25 thirds ---
shape = 0.4132
scale = 23.34

right_skew = lognorm.pdf(days + 1, shape, scale=scale)
right_skew /= right_skew.sum()

left_skew = right_skew[::-1]
left_skew /= left_skew.sum()

daily_frac = left_skew  # fraction of the season’s production that appears each day

# --- convert fraction → kg and berries per day ---
kg_per_day = TOTAL_KG * daily_frac
total_berries = TOTAL_KG * 1000.0 / BERRY_WEIGHT_G
berries_per_day = total_berries * daily_frac

cum_kg = kg_per_day.cumsum()
remaining_kg = TOTAL_KG - cum_kg

cum_ripened = berries_per_day.cumsum()
remaining_berries = total_berries - cum_ripened

# --- harvestable (ripe) berries = last HARVEST_LIFE_DAYS ---
harvestable = []
for T in days:
    start = max(0, T - HARVEST_LIFE_DAYS + 1)
    end = T
    harvestable.append(berries_per_day[start:end+1].sum())
harvestable = np.array(harvestable)
lost_berries = cum_ripened - harvestable

# --- green berries that will ripen within GREEN_WINDOW_DAYS ---
green_on_bush = []
for T in days:
    start = T + 1
    end = min(T + GREEN_WINDOW_DAYS, TABLE_END_DAY)
    if start > end:
        green_on_bush.append(0.0)
    else:
        green_on_bush.append(berries_per_day[start:end+1].sum())
green_on_bush = np.array(green_on_bush)

visible_for_ratio = green_on_bush + harvestable

blue_ratio = []
for h, vis in zip(harvestable, visible_for_ratio):
    if vis == 0:
        blue_ratio.append(np.nan)
    else:
        blue_ratio.append(h / vis)

# --- base plant DataFrame ---
df = pd.DataFrame({
    "day": days,
    "daily_frac": daily_frac,
    "kg": kg_per_day,
    "cum_kg": cum_kg,
    "remaining_kg": remaining_kg,
    "berries_per_day": berries_per_day.astype(int),
    "harvestable_berries": harvestable.astype(int),
    "lost_berries": lost_berries.astype(int),
    "remaining_berries": remaining_berries.astype(int),
    "green_on_bush": green_on_bush.astype(int),
    "visible_for_ratio": visible_for_ratio.astype(int),
    "blue_ratio": np.round(blue_ratio, 3)
})

df["daily_frac"] = df["daily_frac"].round(6)
df["kg"] = df["kg"].round(4)
df["cum_kg"] = df["cum_kg"].round(4)
df["remaining_kg"] = df["remaining_kg"].round(4)

# ======================================================================
# 2) HOW MUCH OF THE CROP FALLS IN EACH THIRD OF THE SEASON? (50 DAYS)
# ======================================================================

total_berries_season = df["berries_per_day"].sum()

n_days_total = TABLE_END_DAY + 1  # 51
block = n_days_total // 3         # 17

first_mask = df["day"].between(0, block - 1)            # 0..16
second_mask = df["day"].between(block, 2*block - 1)     # 17..33
third_mask = df["day"].between(2*block, n_days_total - 1)  # 34..50

first_third = df.loc[first_mask, "berries_per_day"].sum()
second_third = df.loc[second_mask, "berries_per_day"].sum()
third_third = df.loc[third_mask, "berries_per_day"].sum()

pct_first = first_third / total_berries_season * 100
pct_second = second_third / total_berries_season * 100
pct_third = third_third / total_berries_season * 100

print("Distribution of berries in thirds of the (50-day) season:")
print(f"  First third (days 0–16) : {pct_first:5.1f}%")
print(f"  Second third (17–33)    : {pct_second:5.1f}%")
print(f"  Third third (34–50)     : {pct_third:5.1f}%")
print()

# ======================================================================
# 3) SCALE TO FARM LEVEL
# ======================================================================

plant_count = 12000

cols_to_scale = [
    "kg",
    "cum_kg",
    "remaining_kg",
    "berries_per_day",
    "harvestable_berries",
    "lost_berries",
    "remaining_berries",
    "green_on_bush",
]

DataFrameFarm = df.copy()

for col in cols_to_scale:
    DataFrameFarm[col] = DataFrameFarm[col] * plant_count

rename_map = {col: f"farm_{col}" for col in cols_to_scale}
DataFrameFarm = DataFrameFarm.rename(columns=rename_map)

# ======================================================================
# 4) ECONOMICS: PRICE CURVE + FARM_HARVESTABLE_KG + POTENTIAL REVENUE
# ======================================================================

DataFrameFarmEconomics = DataFrameFarm.copy()

price = np.zeros(len(DataFrameFarmEconomics))

# Days 0–5: 15 → 10  (6 points: 0..5)
price[0:6] = np.linspace(15, 10, 6)

# Days 6–10: 10 → 9  (5 points: 6..10)
price[6:11] = np.linspace(10, 9, 5)

# Days 11–20: 8 → 7  (10 points: 11..20)
price[11:21] = np.linspace(8, 7, 10)

# Days 21–34: 6 → 5  (14 points: 21..34)
price[21:35] = np.linspace(6, 5, 14)

# Days 35–50: flat at 3  (35..50)
price[35:51] = 3.0

DataFrameFarmEconomics["price"] = price

print("Average price over the (50-day) season:",
      DataFrameFarmEconomics["price"].mean())
print()

# harvestable berries → kg
DataFrameFarmEconomics["farm_harvestable_kg"] = (
    DataFrameFarmEconomics["farm_harvestable_berries"] * (BERRY_WEIGHT_G / 1000)
)

DataFrameFarmEconomics["potential_revenue"] = (
    DataFrameFarmEconomics["farm_harvestable_kg"] * DataFrameFarmEconomics["price"]
)

# ======================================================================
# 5) MANUAL PICKERS: PARAMETERS & PER-KG ECONOMICS
# ======================================================================

kg_per_picker_per_hour = 4.0       # picker productivity
wage_per_hour = 20.0               # USD/hour
hours_per_day = 8
daily_cost_per_picker = wage_per_hour * hours_per_day  # 160 USD/day

MIN_PICKERS = 20
MAX_PICKERS = 600

material_cost_per_kg = 2.0         # packaging/materials per kg

# ======================================================================
# 6) MACHINE HARVEST: PARAMETERS & GREEN-LOSS PENALTY
# ======================================================================

kg_per_machine_per_hour = 4000.0     # machine throughput (kg/hour)
machine_fixed_cost = 100.0     # fixed cost per day to run machine (huge on purpose)
GREEN_LOSS_FRAC = 0.60


               # fraction of green berries destroyed if machine is used

DataFrameFarmEconomics["farm_green_kg"] = (
    DataFrameFarmEconomics["farm_green_on_bush"] * (BERRY_WEIGHT_G / 1000)
)

# ======================================================================
# 7) UNIFIED STATEFUL SIMULATION:
#    manual vs machine vs wait, with 1-day lookahead for the machine
#    *** dynamic_blue = prev + newly_ripe - overripe - harvested ***
# ======================================================================

n_days = len(DataFrameFarmEconomics)

dynamic_blue_kg = np.zeros(n_days)
harvested_kg = np.zeros(n_days)
action = np.array(["wait"] * n_days, dtype=object)

manual_profit_today = np.zeros(n_days)
machine_profit_today = np.zeros(n_days)
realized_profit = np.zeros(n_days)

pickers_sent = np.zeros(n_days)
machine_used_flag = np.zeros(n_days, dtype=bool)

manual_revenue = np.zeros(n_days)
machine_revenue = np.zeros(n_days)
material_cost_used = np.zeros(n_days)
labor_cost_used = np.zeros(n_days)
machine_fixed_cost_used = np.zeros(n_days)
green_loss_kg_actual = np.zeros(n_days)
green_loss_value_actual = np.zeros(n_days)

net_machine_profit_after_green_loss = np.zeros(n_days)
net_profit_if_wait_one_day = np.zeros(n_days)

# NEW: use daily flows
farm_new_berries = DataFrameFarmEconomics["farm_berries_per_day"].values
berry_kg_factor = BERRY_WEIGHT_G / 1000.0

prev_dynamic_blue = 0.0  # ripe kg on bush at end of previous day

for t in range(n_days):
    price_today = DataFrameFarmEconomics.loc[t, "price"]
    green_kg_today = DataFrameFarmEconomics.loc[t, "farm_green_kg"]

    # --------------------------------------------------------------
    # 1) update ripe inventory BEFORE harvest
    #    dynamic_blue_today = prev + newly_ripe - overripe
    # --------------------------------------------------------------
    newly_ripe_kg_today = farm_new_berries[t] * berry_kg_factor

    if t >= HARVEST_LIFE_DAYS:
        overripe_kg_today = farm_new_berries[t - HARVEST_LIFE_DAYS] * berry_kg_factor
    else:
        overripe_kg_today = 0.0

    dynamic_blue_today = prev_dynamic_blue + newly_ripe_kg_today - overripe_kg_today
    if dynamic_blue_today < 0:
        dynamic_blue_today = 0.0

    dynamic_blue_kg[t] = dynamic_blue_today

    if dynamic_blue_today <= 0:
        prev_dynamic_blue = dynamic_blue_today
        continue

    # ------------------------------------------------------------------
    # 2) MANUAL HARVEST OPTION
    # ------------------------------------------------------------------
    required_pickers = dynamic_blue_today / (kg_per_picker_per_hour * hours_per_day)
    within_limits = (required_pickers >= MIN_PICKERS) and (required_pickers <= MAX_PICKERS)

    if within_limits:
        manual_rev = dynamic_blue_today * price_today
        manual_lab_cost = required_pickers * daily_cost_per_picker
        manual_mat_cost = dynamic_blue_today * material_cost_per_kg
        profit_manual = manual_rev - manual_lab_cost - manual_mat_cost
    else:
        manual_rev = 0.0
        manual_lab_cost = 0.0
        manual_mat_cost = 0.0
        profit_manual = -np.inf

    # ------------------------------------------------------------------
    # 3) MACHINE HARVEST OPTION TODAY (with green-loss penalty)
    # ------------------------------------------------------------------
    next_price = DataFrameFarmEconomics.loc[min(t + 1, n_days - 1), "price"]

    machine_rev_today = dynamic_blue_today * price_today
    machine_mat_cost_today = dynamic_blue_today * material_cost_per_kg
    machine_profit_gross_today = machine_rev_today - machine_mat_cost_today - machine_fixed_cost

    green_loss_kg_today = GREEN_LOSS_FRAC * green_kg_today
    green_loss_value_today = green_loss_kg_today * next_price

    net_machine_today = machine_profit_gross_today - green_loss_value_today

    # ------------------------------------------------------------------
    # 4) LOOKAHEAD: WHAT IF WE WAIT ONE DAY AND THEN USE MACHINE?
    # ------------------------------------------------------------------
    if t == n_days - 1:
        net_machine_if_wait = -1e12
    else:
        newly_ripe_kg_tomorrow = farm_new_berries[t + 1] * berry_kg_factor
        if (t + 1) >= HARVEST_LIFE_DAYS:
            overripe_kg_tomorrow = farm_new_berries[t + 1 - HARVEST_LIFE_DAYS] * berry_kg_factor
        else:
            overripe_kg_tomorrow = 0.0

        dynamic_blue_tomorrow_if_wait = (
            dynamic_blue_today + newly_ripe_kg_tomorrow - overripe_kg_tomorrow
        )
        if dynamic_blue_tomorrow_if_wait < 0:
            dynamic_blue_tomorrow_if_wait = 0.0

        price_tomorrow = DataFrameFarmEconomics.loc[t + 1, "price"]

        machine_revenue_tomorrow = dynamic_blue_tomorrow_if_wait * price_tomorrow
        machine_material_cost_tomorrow = dynamic_blue_tomorrow_if_wait * material_cost_per_kg
        machine_profit_gross_tomorrow = (
            machine_revenue_tomorrow - machine_material_cost_tomorrow - machine_fixed_cost
        )

        green_kg_tomorrow = DataFrameFarmEconomics.loc[t + 1, "farm_green_kg"]
        next_next_price = DataFrameFarmEconomics.loc[min(t + 2, n_days - 1), "price"]
        green_loss_kg_tomorrow = GREEN_LOSS_FRAC * green_kg_tomorrow
        green_loss_value_tomorrow = green_loss_kg_tomorrow * next_next_price

        net_machine_if_wait = machine_profit_gross_tomorrow - green_loss_value_tomorrow

    net_machine_profit_after_green_loss[t] = net_machine_today
    net_profit_if_wait_one_day[t] = net_machine_if_wait

    # ------------------------------------------------------------------
    # 5) DECISION LOGIC
    # ------------------------------------------------------------------
    best_immediate = max(profit_manual, net_machine_today, 0.0)

    if best_immediate <= 0:
        action[t] = "wait"
        harvested_kg[t] = 0.0
        realized_profit[t] = 0.0
        prev_dynamic_blue = dynamic_blue_today

    else:
        # manual dominates
        if (profit_manual > 0) and (profit_manual >= net_machine_today):
            action[t] = "manual"
            harvested_kg[t] = dynamic_blue_today
            realized_profit[t] = profit_manual

            pickers_sent[t] = required_pickers
            manual_profit_today[t] = profit_manual
            manual_revenue[t] = manual_rev
            labor_cost_used[t] = manual_lab_cost
            material_cost_used[t] = manual_mat_cost

            machine_profit_today[t] = 0.0
            machine_used_flag[t] = False
            machine_fixed_cost_used[t] = 0.0
            green_loss_kg_actual[t] = 0.0
            green_loss_value_actual[t] = 0.0

            prev_dynamic_blue = dynamic_blue_today - harvested_kg[t]

        else:
            if (net_machine_today > 0) and (net_machine_today >= net_machine_if_wait):
                action[t] = "machine"
                harvested_kg[t] = dynamic_blue_today
                realized_profit[t] = net_machine_today

                machine_used_flag[t] = True
                machine_profit_today[t] = net_machine_today
                machine_revenue[t] = machine_rev_today
                material_cost_used[t] = machine_mat_cost_today
                machine_fixed_cost_used[t] = machine_fixed_cost
                green_loss_kg_actual[t] = green_loss_kg_today
                green_loss_value_actual[t] = green_loss_value_today

                pickers_sent[t] = 0.0
                manual_profit_today[t] = 0.0
                labor_cost_used[t] = 0.0
                manual_revenue[t] = 0.0

                prev_dynamic_blue = dynamic_blue_today - harvested_kg[t]

            else:
                action[t] = "wait"
                harvested_kg[t] = 0.0
                realized_profit[t] = 0.0
                prev_dynamic_blue = dynamic_blue_today

# ======================================================================
# 8) ATTACH RESULTS TO A SINGLE "FARM_SIMULATION" DATAFRAME
# ======================================================================

FarmSimulation = DataFrameFarmEconomics.copy()

FarmSimulation["dynamic_blue_kg"] = dynamic_blue_kg
FarmSimulation["harvested_kg"] = harvested_kg
FarmSimulation["action"] = action
FarmSimulation["realized_profit"] = realized_profit

FarmSimulation["manual_profit_if_used"] = manual_profit_today
FarmSimulation["machine_profit_if_used"] = machine_profit_today

FarmSimulation["pickers_sent"] = pickers_sent
FarmSimulation["machine_used_today"] = machine_used_flag

FarmSimulation["manual_revenue"] = manual_revenue
FarmSimulation["machine_revenue"] = machine_revenue

FarmSimulation["material_cost_used"] = material_cost_used
FarmSimulation["labor_cost_used"] = labor_cost_used
FarmSimulation["machine_fixed_cost_used"] = machine_fixed_cost_used

FarmSimulation["green_loss_kg_actual"] = green_loss_kg_actual
FarmSimulation["green_loss_value_actual"] = green_loss_value_actual

FarmSimulation["net_machine_profit_after_green_loss_today"] = net_machine_profit_after_green_loss
FarmSimulation["net_profit_if_wait_one_day_machine"] = net_profit_if_wait_one_day

print(FarmSimulation[["day", "price", "dynamic_blue_kg", "action",
                      "harvested_kg", "realized_profit"]])

# ======================================================================
# 9) SIMPLE PLOTS TO SEE WHEN EACH METHOD IS USED
# ======================================================================

fig, axes = plt.subplots(3, 1, figsize=(12, 12), sharex=True)

# 1) Dynamic blue + harvest decisions
ax1 = axes[0]
ax1.plot(FarmSimulation["day"], FarmSimulation["dynamic_blue_kg"],
         label="Dynamic blue kg on bush")

mask_manual = FarmSimulation["action"] == "manual"
mask_machine = FarmSimulation["action"] == "machine"

ax1.scatter(FarmSimulation.loc[mask_manual, "day"],
            FarmSimulation.loc[mask_manual, "dynamic_blue_kg"],
            label="Manual harvest", marker="o")
ax1.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "dynamic_blue_kg"],
            label="Machine harvest", marker="x")

ax1.set_ylabel("Blue kg on bush")
ax1.set_title("Dynamic blue kg & harvest decisions")
ax1.legend()
ax1.grid(True)

# 2) Price curve
ax2 = axes[1]
ax2.plot(FarmSimulation["day"], FarmSimulation["price"], label="Price (USD/kg)")
ax2.set_ylabel("Price")
ax2.set_title("Price curve")
ax2.grid(True)

# 3) Realized profit
ax3 = axes[2]
ax3.bar(FarmSimulation["day"], FarmSimulation["realized_profit"])
ax3.set_xlabel("Day")
ax3.set_ylabel("Realized profit (USD)")
ax3.set_title("Realized profit per day (manual or machine)")
ax3.grid(True)

plt.tight_layout()
plt.show()

# 1) Dynamic blue + harvest decisions
plt.figure(figsize=(12, 4))
plt.plot(FarmSimulation["day"], FarmSimulation["dynamic_blue_kg"],
         label="Dynamic blue kg on bush")

mask_manual = FarmSimulation["action"] == "manual"
mask_machine = FarmSimulation["action"] == "machine"

plt.scatter(FarmSimulation.loc[mask_manual, "day"],
            FarmSimulation.loc[mask_manual, "dynamic_blue_kg"],
            label="Manual harvest", marker="o")
plt.scatter(FarmSimulation.loc[mask_machine, "day"],
            FarmSimulation.loc[mask_machine, "dynamic_blue_kg"],
            label="Machine harvest", marker="x")

plt.ylabel("Blue kg on bush")
plt.title("Dynamic blue kg & harvest decisions")
plt.legend()
plt.grid(True)
plt.show()

# 2) Price curve
plt.figure(figsize=(12, 4))
plt.plot(FarmSimulation["day"], FarmSimulation["price"], label="Price (USD/kg)")
plt.ylabel("Price")
plt.title("Price curve")
plt.grid(True)
plt.show()

# 3) Realized profit
plt.figure(figsize=(12, 4))
plt.bar(FarmSimulation["day"], FarmSimulation["realized_profit"])
plt.xlabel("Day")
plt.ylabel("Realized profit (USD)")
plt.title("Realized profit per day (manual or machine)")
plt.grid(True)
plt.show()